# memo

## [エフェクトを使って同期を行う – React](https://ja.react.dev/learn/synchronizing-with-effects)

Reactのレンダーコードは純粋でなければならない。レンダーコードとは、コンポーネントのトップレベルで実行されているコードのこと。

また、ユーザーからの入力に応じた処理は、イベントハンドラとして記述できる。処理のきっかけがユーザーではないものは、Reactではエフェクトを使って実装する。

Reactのエフェクトは、コンポーネントがコミット（コンポーネントがレンダーされて、DOMに反映されること）された時に実行される。依存配列を指定すれば、その値が更新されたときにのみ実行される。

🐤 開発環境で、Reactがコンポーネントを2回マウントするのは何のためか？

useEffectに関して言えば、2回実行することで、エフェクトのクリーンアップの記述が漏れていないか確認することができる。

チャレンジ問題をやってみる。

1.マウント時にフォーカス

これは、マウント後に一回だけ実行されればいいので、useEffectの依存配列に[]を指定すればOK。

2.条件付きでフィールドにフォーカス

確かに、1の実装だと、2つのコンポーネントがあるときは、エフェクトが後から実行される方のコンポーネントにフォーカスが当たる。

`shouldFocus`をpropsとして受け取って、shouldFocusが`true`の時だけフォーカスが当たるようにする。

エフェクトがどのように実行されるか考えてみる。例えば、`shouldFocus=true`となるコンポーネントが、2つ目に変わったとする。そうなると、全ての`Input`コンポーネントでエフェクトが呼び出され、`true`となっているコンポーネントで`ref.current.focus()`が実行される。

若干冗長な処理になっているような気がしなくもない。

3.2回実行されるインターバルを修正

あ〜、これは基本的なJavaScriptの知識が不足しているのを感じる。setIntervalというのが、普通のJavaScriptで何に属しているのか（どこで実行されるのか←window?）が分からない。

それは置いておいて、問題の原因はReactが開発環境でコンポーネントを2回マウントするので、エフェクトが2回実行されており、setIntervalが2回実行されていることにある。setInvervalに関しては、アンマウント時に実行されるクリーンアップ関数に、clearIntervalを書いてあげればOK。

intervalIdは、描画に関係ないからrefでもっておけば良さそうだけど、書き方が分からない。適当に書いたら動いた。ミュータブルなコードになっているのが少し気持ち悪い。

```ts
const intervalId = useRef(0);

useEffect(() => {
  function onTick() {
    setCount(c => c + 1);
  }
  intervalId.current = setInterval(onTick, 1000);

  return () => clearInterval(intervalId.current)
}, []);
```

↑答えを確認。これ、`intervalId`はエフェクトの中で使うだけなので、エフェクトの中で変数を宣言すればOK。なるほど。

4.エフェクト内のフェッチを修正

普通のコードに見えるけれど、Bobを選択した後に素早くTaylorを選択すると、Bobの情報が表示されてしまうという問題がある。これは、APIの取得に、TaylorのデータよりBobのデータの方が時間がかかっているから。

Bobのときのエフェクトが実行される
Taylorのときのエフェクトが実行される
Taylorのときのエフェクトが実行が完了する
Bobのときのエフェクトの実行が完了する

Bobのときのレンダーについて、クリーンアップする必要がある。Promiseをキャンセルするコードをクリーンアップ関数に書けばいいのかな。実装方法は思いつかないのでヒントを見てみる。

答えを確認。もう次のエフェクトが実行されていますよ...というのを`ignore = true`で表す。クリーンアップ関数で`ignore = true`にすれば、最後に実行されたエフェクトだけ`ignore = false`になっているので、最後の結果だけ表示できる。

エフェクトが複数実行されていることを考えなければならないので、とてもややこしい。

```js
useEffect(() => {
  let isLastEffect = true;

  setBio(null);
  fetchBio(person).then(result => {
    if (isLastEffect) {
        setBio(result);
    }
  });

  return () => isLastEffect = false;
}, [person]);
```

## [そのエフェクトは不要かも – React](https://ja.react.dev/learn/you-might-not-need-an-effect)

何かと話題になっている記事。今は理解するための情報が揃っていると思うので、理解したい。

エフェクトはReactの外のシステムに同期するためのものなので、そうではない場合はEffectを使う必要はない。

* propsまたはstateに基づいてpropsを更新する

これは、普通に計算する処理をレンダーコードに入れてあげればよい。前実装していた時に、propsやstateに基づいて更新するけれど、リアルタイムに反映させたくないということがあった。これの解決方法はまだ分かっていない。

* 重たい計算のキャッシュ

レンダーコードは毎回実行されるので、関係のないstateやpropsが更新されたときに計算しないようにしたければ、useMemoを使ってキャッシュする。

* propsが変更されたときに全てのstateをリセットする

ユーザーページにcomment変数があり、別のユーザーページに行ってもcommentの内容が引き継がれてしまうという問題。確かに、この状況だとuseEffectを使いたくなる。

これは、keyにuserIdを渡すことによって、ステートを共有するべきではない別のコンポーネントと認識させて解決するらしい。

* propsが変更されたときに一部のstateをリセットする

これ難しい

* イベントハンドラ間でのロジックの共有

これは、イベントハンドラに書くべきロジックを、エフェクトに書くべきではないと書かれている。イベントハンドラには、ユーザーのアクションに応じて行う処理を書く。エフェクトには、コンポーネントが描画されたことによって行う処理を書く。

「商品をカートに追加しときに通知をする」というのは、ユーザーのアクションに応じた処理なので、イベントハンドラに書く。

* 計算の数珠繋ぎ

後で読む

* アプリケーションの初期化

Reactのトップレベルのコードは、コンポーネントがインポートされた時に一度だけ実行される。それを利用して、トップレベルに`didInit`変数を持たせたり、あるいは直接初期化のコードを書くことで、一度だけ初期化を行うことができる。

わかりづらくなるので、乱用厳禁のパターン。

* 親コンポーネントへのstateの変更の通知

親コンポーネントの通知は、Reactではコールバックをpropsとして受け取って、実行すると思う。これをuseEffectを使わずにやろうと思ったら、state liftingしないといけない、みたいな感じの結論になると予想。

↑大体あってた。これ状況が想像しにくいからあんまり理解できてない。

* 親にデータを渡す

これ久しぶりにReactを使ったので忘れててやってしまったやつ。「親にデータを渡すということは親もデータが必要だいうことなので、親から子にpropsで渡すようにしましょう」←これ言われて見ればそれはそうという感じだ...。

データを子から親に渡すこともできるけれど、流れが追跡しにくくなるのでやるべきではない。親から子に渡すようにする。

* 外部ストアへのサブスクライブ

`useSyncExternalStore`だ！よく聞くけど知らないやつ。

navigator.onLine（ブラウザがオンライン状態になっているか）を、ステートに同期させている。useEffectを使うコードは理解できる。

`useSyncExternalStore`はよくわからなかった。

* データのフェッチ

この、古いデータを無視するというのは、前回のセクションで実装した内容。データフェッチに関する問題はレースコンディション以外にも色々あるので、ライブラリを使うか、そうでなければカスタムフックを作るのが良い。

### チャレンジ問題

1.エフェクトなしでデータを変換

結構実践的な問題。ユーザーのアクションは、show only active todosにチェックを入れる、todoを追加するの2つ。

ステートとしては、todosを持っておけば良い。

visibleTodosというステートも不要。これは、showActiveがtrueだとactiveのみ、falseだと全てのtodo。

footerについて。これJSXをステートに入れるの初めてみた。これもeffectを使わずに計算してあげればOK。

```js
const [todos, setTodos] = useState(initialTodos);
const [showActive, setShowActive] = useState(false);

const activeTodos = todos.filter(todo => !todo.completed);
const visibleTodos = showActive ? activeTodos : todos;
const footer = <footer>{activeTodos.length} todos left</footer>
```

メモ化はしていない。showActiveの時にactiveTodosを計算しているのが、キャッシュしても良い部分。

2.エフェクトなしで計算結果をキャッシュ

useMemoを使ってtextの更新では再計算が走らないようにできたけれど、showActiveを更新すると何故か計算処理が2回実行されている。

↑これは原因はわからないけれど、答えの方もそうなっていたのでこういう仕様らしい。

3.エフェクトなしでstateをセット

key使えば良さそうなことはわかるけれど、どこを別コンポーネントに切り出すかの判断ができないので答えを見てみる。

回答を確認。なるほど。コンポーネントを抽出するのではなくてラップすれば良い。それぞれが別のフォームだと認識できるように、ラップしたコンポーネントから、元のコンポーネントにkeyを渡してあげる。そうすれば、keyが変わったときにコンポーネントが再生成され、ステートが受け継がれなくなる。

「別のコンポーネントとして考えられる」「別のコンポーネントと認識させても良い」状況だとこの方法が使える。実際のところ、stateをリセットしたい場合にこの状況に当てはまらないこともあると思うので、その場合はuseEffectを使うことになるのかな...？

↑ユーザーのアクションでリセットしたい場合は、イベントに書けばよいだけ。具体的な例は何かあるだろうか。

4.エフェクトなしでフォームを送信

イベントで書くべきところを、エフェクトで書いているのが原因。これは直すべきところが明らかなので、直す。

## [リアクティブなエフェクトのライフサイクル – React](https://ja.react.dev/learn/lifecycle-of-reactive-effects)


コンポーネントがマウント、更新、アンマウントされるように、エフェクトも同期の開始、再同期、同期の終了が行われる。

そして、エフェクトを実装するときは、同期を開始する方法と、同期を終了する方法だけを書けばよい。そうすれば、あとはReactが同期の開始、再同期、終了をよしなにやってくれる。これは、JSXを記述すれば、ReactがUIの更新を勝手にやってくれることと似ている。

依存配列が空のエフェクトについて。依存配列が空ということは再同期をしないということなので、マウント時に同期し、アンマウント時に同期を終了する。つまり、コンポーネントの表示とともに、1回だけエフェクトが実行される。

🐤「エフェクトはリアクティブなコードブロックです」これちょっと分からない

Aはリアクティブな値である→Aを変更したときに、再レンダリングが発生するという意味。

エフェクトは、その中で読み取っている値（レンダーコード、つまり関数のトップレベルで計算される値）が更新されたときに実行される。

変数がリアクティブであることと、エフェクトがリアクティブであることはちょっと意味が違いそうだけど、なんとなく理解はできた。

（オブジェクトを依存配列に指定してはいけないと書かれていて、これやってしまいそうなミスではある。←ステートにオブジェクトを持たせている場合は大丈夫なのかな？）

### チャレンジ問題

1.キー入力による再接続を防ぐ

これは、useEffectに依存配列を指定していないため、エフェクトが再レンダリングの度に実行されている。依存配列（`roomId`）を指定してあげればOK。

2.同期の有無を切り替える

`canMove`変数の状態に合わせて、ドットを動かすことができるかどうかが決まるようにする。

これは、`canMove`がtrueのときだけイベントリスナを設定するようにすればいいのかな？

イベントハンドラは設定したままで、中で`canMove`の値に応じて処理するようにするのが直感的だとは思うけれど、イベントハンドラからReactのステートを見ることはできないような気がするので、こうするしかないかも。

```js
useEffect(() => {
  function handleMove(e) {
    setPosition({ x: e.clientX, y: e.clientY });
  }
  if (canMove) {
    window.addEventListener('pointermove', handleMove);
  }

  return () => {
    if (canMove) {
        window.removeEventListener('pointermove', handleMove);
    }
  }
}, [canMove]);
```

↓でOK。canMove=trueのときはイベントリスナを設定し、falseのときは設定しないようにしている。

あるいは、イベントハンドラの中で条件分岐することも可能。この場合は、canMove=trueでもfalseでもイベントリスナは設定されるが、trueのときだけステートが更新される。クロージャがステートの値をキャプチャしているのかな...？

```js
useEffect(() => {
  function handleMove(e) {
    setPosition({ x: e.clientX, y: e.clientY });
  }
  if (canMove) {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('poinermove', handleMove)
  }
}, [canMove]);
```

3.更新前の値が残るバグを調査

うわーこれ多分答えは簡単ですが、間違ったコードで起こっている現象を理解するのが難しそうですね。

1.エフェクトはコンポーネントのマウント時に一度だけセットされる
2.その時に、イベントリスナに設定しているクロージャが、ステート値（canMove=true）をキャプチャする
3.なので、setPositionの呼び出しは、canMoveステートの変更に関わらず常に実行される

なので、再同期する度にイベントハンドラを作るようにしてあげればOK。答えは2と同じ。

↑コンポーネントのトップレベルで宣言されている関数が、毎レンダリングで作成されるという認識は抜けていました。

4.接続の切り替えを修正

これは、チェックボックスをチェックしたタイミングで、エフェクトが再同期されないのが原因。createConnectionを依存配列に指定してあげればOKだと思う。

↑解決策としてはこれでOK。

しかし、関数を受け取るようにすると、インライン関数を受け取った場合にエフェクトの再同期が頻繁に起こる可能性がある。なので、propsとしてはisEncryptedを受け取るようにした方がよい。

5.連動する選択ボックスの作成

惑星を選択したときに、場所のリストを取得して、セットする処理を書けば良い。これはイベントなので、イベントハンドラを書く。とりあえず動くものはできたが、色々改善点がありそうなモヤっとするコードになった。

これエフェクトで書くんですね...ちょっと気持ち悪いかも...。

カスタムフックを使用しているコードは、お見事。このカスタムフックでは、optionに必要なステートを宣言し、外部APIからリストを取得し、取得した最初の結果をステートにセットする、というロジックを抽出している。

最初に感じた気持ち悪さも、「オプションのリストに必要な値と、外部APIから取得できる値を同期している」「外部APIの存在を見えなくしている」とい考えると、納得がいくような気がした。

### 感想

エフェクトとは何か？→同期の開始と終了を行うもの。また、リアクティブな値の変化に応じて、再同期を行うもの。

## エフェクトからイベントを分離する

`useEffectEvent`、個人的な例でこの場合に使えそうだなというのは理解したものの、覚えていないので理解しよう。

画面の表示をトリガーに動くものは、エフェクト。ユーザーのアクションをトリガーに動くものは、イベントハンドラ。

↑エフェクトは同期が必要な場合に使うもの。

選択中のチャットルームに接続する→エフェクト
送信ボタンをクリックすると送信→イベントハンドラ

リアクティビティに注目して、イベントハンドラとエフェクトを区別することが書かれている。これなるほど。コネクションを維持するのは、`roomId`が変更したときに実行したいので、エフェクト。メッセージの送信は、メッセージが変わったときに実行されたいわけではないので、イベントハンドラ。

エフェクトから非リアクティブなロジックを分離するために、`useEffectEvent`を使う。

コネクションを維持するコード（リアクティブ）と、通知を表示するコード（非リアクティブ）がある。前者はroomId、後者はthemeに依存しているので、この処理はroomIdとthemeに反応するエフェクトになる。

しかし、そうするとthemeを変更しても再接続されてしまうので、themeに依存した通知処理はエフェクトイベントに切り離す。


## [2023 年、改めて React と Elm Architecture を比較する - ジンジャー研究室](https://jinjor-labo.hatenablog.com/entry/2023/03/30/061358)

ReactとElmの違いが気になったので検索。コンポーネントが状態をもっているか、そうではないかという違いがあるけれど、それぞれどのようなメリットがあるのか、副作用やイベントの扱いはどう違うのか、が気になったので読んでみる。
