# memo

## [エフェクトを使って同期を行う – React](https://ja.react.dev/learn/synchronizing-with-effects)

Reactのレンダーコードは純粋でなければならない。レンダーコードとは、コンポーネントのトップレベルで実行されているコードのこと。

また、ユーザーからの入力に応じた処理は、イベントハンドラとして記述できる。処理のきっかけがユーザーではないものは、Reactではエフェクトを使って実装する。

Reactのエフェクトは、コンポーネントがコミット（コンポーネントがレンダーされて、DOMに反映されること）された時に実行される。依存配列を指定すれば、その値が更新されたときにのみ実行される。

🐤 開発環境で、Reactがコンポーネントを2回マウントするのは何のためか？

useEffectに関して言えば、2回実行することで、エフェクトのクリーンアップの記述が漏れていないか確認することができる。

チャレンジ問題をやってみる。

1.マウント時にフォーカス

これは、マウント後に一回だけ実行されればいいので、useEffectの依存配列に[]を指定すればOK。

2.条件付きでフィールドにフォーカス

確かに、1の実装だと、2つのコンポーネントがあるときは、エフェクトが後から実行される方のコンポーネントにフォーカスが当たる。

`shouldFocus`をpropsとして受け取って、shouldFocusが`true`の時だけフォーカスが当たるようにする。

エフェクトがどのように実行されるか考えてみる。例えば、`shouldFocus=true`となるコンポーネントが、2つ目に変わったとする。そうなると、全ての`Input`コンポーネントでエフェクトが呼び出され、`true`となっているコンポーネントで`ref.current.focus()`が実行される。

若干冗長な処理になっているような気がしなくもない。

3.2回実行されるインターバルを修正

あ〜、これは基本的なJavaScriptの知識が不足しているのを感じる。setIntervalというのが、普通のJavaScriptで何に属しているのか（どこで実行されるのか←window?）が分からない。

それは置いておいて、問題の原因はReactが開発環境でコンポーネントを2回マウントするので、エフェクトが2回実行されており、setIntervalが2回実行されていることにある。setInvervalに関しては、アンマウント時に実行されるクリーンアップ関数に、clearIntervalを書いてあげればOK。

intervalIdは、描画に関係ないからrefでもっておけば良さそうだけど、書き方が分からない。適当に書いたら動いた。ミュータブルなコードになっているのが少し気持ち悪い。

```ts
const intervalId = useRef(0);

useEffect(() => {
  function onTick() {
    setCount(c => c + 1);
  }
  intervalId.current = setInterval(onTick, 1000);

  return () => clearInterval(intervalId.current)
}, []);
```

↑答えを確認。これ、`intervalId`はエフェクトの中で使うだけなので、エフェクトの中で変数を宣言すればOK。なるほど。

4.エフェクト内のフェッチを修正

普通のコードに見えるけれど、Bobを選択した後に素早くTaylorを選択すると、Bobの情報が表示されてしまうという問題がある。これは、APIの取得に、TaylorのデータよりBobのデータの方が時間がかかっているから。

Bobのときのエフェクトが実行される
Taylorのときのエフェクトが実行される
Taylorのときのエフェクトが実行が完了する
Bobのときのエフェクトの実行が完了する

Bobのときのレンダーについて、クリーンアップする必要がある。Promiseをキャンセルするコードをクリーンアップ関数に書けばいいのかな。実装方法は思いつかないのでヒントを見てみる。

答えを確認。もう次のエフェクトが実行されていますよ...というのを`ignore = true`で表す。クリーンアップ関数で`ignore = true`にすれば、最後に実行されたエフェクトだけ`ignore = false`になっているので、最後の結果だけ表示できる。

エフェクトが複数実行されていることを考えなければならないので、とてもややこしい。

```js
useEffect(() => {
  let isLastEffect = true;

  setBio(null);
  fetchBio(person).then(result => {
    if (isLastEffect) {
        setBio(result);
    }
  });

  return () => isLastEffect = false;
}, [person]);
```

## [そのエフェクトは不要かも – React](https://ja.react.dev/learn/you-might-not-need-an-effect)

何かと話題になっている記事。今は理解するための情報が揃っていると思うので、理解したい。

エフェクトはReactの外のシステムに同期するためのものなので、そうではない場合はEffectを使う必要はない。

* propsまたはstateに基づいてpropsを更新する

これは、普通に計算する処理をレンダーコードに入れてあげればよい。前実装していた時に、propsやstateに基づいて更新するけれど、リアルタイムに反映させたくないということがあった。これの解決方法はまだ分かっていない。

* 重たい計算のキャッシュ

レンダーコードは毎回実行されるので、関係のないstateやpropsが更新されたときに計算しないようにしたければ、useMemoを使ってキャッシュする。

* propsが変更されたときに全てのstateをリセットする

ユーザーページにcomment変数があり、別のユーザーページに行ってもcommentの内容が引き継がれてしまうという問題。確かに、この状況だとuseEffectを使いたくなる。

これは、keyにuserIdを渡すことによって、ステートを共有するべきではない別のコンポーネントと認識させて解決するらしい。

* propsが変更されたときに一部のstateをリセットする

これ難しい

* イベントハンドラ間でのロジックの共有

これは、イベントハンドラに書くべきロジックを、エフェクトに書くべきではないと書かれている。イベントハンドラには、ユーザーのアクションに応じて行う処理を書く。エフェクトには、コンポーネントが描画されたことによって行う処理を書く。

「商品をカートに追加しときに通知をする」というのは、ユーザーのアクションに応じた処理なので、イベントハンドラに書く。

* 計算の数珠繋ぎ

後で読む

* アプリケーションの初期化

Reactのトップレベルのコードは、コンポーネントがインポートされた時に一度だけ実行される。それを利用して、トップレベルに`didInit`変数を持たせたり、あるいは直接初期化のコードを書くことで、一度だけ初期化を行うことができる。

わかりづらくなるので、乱用厳禁のパターン。

* 親コンポーネントへのstateの変更の通知

親コンポーネントの通知は、Reactではコールバックをpropsとして受け取って、実行すると思う。これをuseEffectを使わずにやろうと思ったら、state liftingしないといけない、みたいな感じの結論になると予想。

↑大体あってた。これ状況が想像しにくいからあんまり理解できてない。

* 親にデータを渡す

これ久しぶりにReactを使ったので忘れててやってしまったやつ。「親にデータを渡すということは親もデータが必要だいうことなので、親から子にpropsで渡すようにしましょう」←これ言われて見ればそれはそうという感じだ...。

データを子から親に渡すこともできるけれど、流れが追跡しにくくなるのでやるべきではない。親から子に渡すようにする。

* 外部ストアへのサブスクライブ

`useSyncExternalStore`だ！よく聞くけど知らないやつ。

navigator.onLine（ブラウザがオンライン状態になっているか）を、ステートに同期させている。useEffectを使うコードは理解できる。

`useSyncExternalStore`はよくわからなかった。

* データのフェッチ

この、古いデータを無視するというのは、前回のセクションで実装した内容。データフェッチに関する問題はレースコンディション以外にも色々あるので、ライブラリを使うか、そうでなければカスタムフックを作るのが良い。


---

チャレンジ問題を解きます。

1.エフェクトなしでデータを変換

結構実践的な問題。ユーザーのアクションは、show only active todosにチェックを入れる、todoを追加するの2つ。

ステートとしては、todosを持っておけば良い。

visibleTodosというステートも不要。これは、showActiveがtrueだとactiveのみ、falseだと全てのtodo。

footerについて。これJSXをステートに入れるの初めてみた。これもeffectを使わずに計算してあげればOK。

```js
const [todos, setTodos] = useState(initialTodos);
const [showActive, setShowActive] = useState(false);

const activeTodos = todos.filter(todo => !todo.completed);
const visibleTodos = showActive ? activeTodos : todos;
const footer = <footer>{activeTodos.length} todos left</footer>
```

メモ化はしていない。showActiveの時にactiveTodosを計算しているのが、キャッシュしても良い部分。

2.エフェクトなしで計算結果をキャッシュ

useMemoを使ってtextの更新では再計算が走らないようにできたけれど、showActiveを更新すると何故か計算処理が2回実行されている。

↑これは原因はわからないけれど、答えの方もそうなっていたのでこういう仕様らしい。

3.エフェクトなしでstateをセット

key使えば良さそうなことはわかるけれど、どこを別コンポーネントに切り出すかの判断ができないので答えを見てみる。

回答を確認。なるほど。コンポーネントを抽出するのではなくてラップすれば良い。それぞれが別のフォームだと認識できるように、ラップしたコンポーネントから、元のコンポーネントにkeyを渡してあげる。そうすれば、keyが変わったときにコンポーネントが再生成され、ステートが受け継がれなくなる。

「別のコンポーネントとして考えられる」「別のコンポーネントと認識させても良い」状況だとこの方法が使える。実際のところ、stateをリセットしたい場合にこの状況に当てはまらないこともあると思うので、その場合はuseEffectを使うことになるのかな...？

↑ユーザーのアクションでリセットしたい場合は、イベントに書けばよいだけ。具体的な例は何かあるだろうか。

4.エフェクトなしでフォームを送信

イベントで書くべきところを、エフェクトで書いているのが原因。これは直すべきところが明らかなので、直す。


## [2023 年、改めて React と Elm Architecture を比較する - ジンジャー研究室](https://jinjor-labo.hatenablog.com/entry/2023/03/30/061358)

ReactとElmの違いが気になったので検索。コンポーネントが状態をもっているか、そうではないかという違いがあるけれど、それぞれどのようなメリットがあるのか、副作用やイベントの扱いはどう違うのか、が気になったので読んでみる。
